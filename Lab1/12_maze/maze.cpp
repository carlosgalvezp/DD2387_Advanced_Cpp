#include "../11_matrix/Matrix.h"         // inkludera din headerfil har
#include <iostream>

Matrix maze, visited, path;
std::size_t startX(-1), startY(-1), endX(-1), endY(-1);

void read(const char** data);
void findStartGoal(std::size_t &startX, std::size_t &startY, std::size_t &endX, std::size_t &endY);
bool inBorder(std::size_t x, std::size_t y, std::size_t x_max, std::size_t y_max);

bool solve_maze(std::size_t x, std::size_t y);
void solve(const char** file);

int main()
{
    const char *small[] =
	{"#####################",
	 "      # # #   # # # #",
	 "##### #     # #   # #",
	 "#     ##### # # #   #",
	 "### # #   # #   # # #",
	 "# # # # # # ####### #",
	 "#   #   #   #       #",
	 "## ############ #####",
	 "#   #                ",
	 "#####################",
	 0};
    
    const char *medium[] =
	{"# #######################################",
	 "# #                   #     #   #     # #",
	 "# # ### ############# # # ### # # ### # #",
	 "# #   #     #   #   #   #     # #   # # #",
	 "# ### # ### # # # # ##### ####### # # # #",
	 "#   # # # #   #   #     #   #   # # # # #",
	 "### # # # # ########### ##### # ### # # #",
	 "#   # #   #   # #             # #   # # #",
	 "# # # ####### # # ############# # ### # #",
	 "# # #     #   # #             # #   # # #",
	 "# ### ### # ### ############# # ### # # #",
	 "#   #   # #   #   #     #   # # #   # # #",
	 "### ##### ### ### # # ### # # # # ### # #",
	 "#   #     # # #     #     # # # # # #   #",
	 "# ### ##### # # ############# # # # # ###",
	 "#     #     # #               # # # #   #",
	 "####### ##### ################### # # ###",
	 "#         #   #     #             # #   #",
	 "# ####### # ### # # # ############# ### #",
	 "#       #       # #               #     #",
	 "####################################### #",
	 0};

    const char *large[] =
	{"# ###############################################################################",
	 "# #         # #     #       #         #       #   #     #     #   #             #",
	 "# ### ##### # # ### # ##### # ##### # # ### ### # # ### ##### # # # # ##### #####",
	 "#   # #   # # # # #   #     # #   # #   # #   # # # # #     # # #   # #   # #   #",
	 "# # # # # # # # # ### # ##### # # # ##### # # # # # # # ### # # ##### # # ### # #",
	 "# #   # #     # # #   #     #   # # #   #   #   # # # # # #   #     #   # #   # #",
	 "####### ####### # # ### ######### ### ####### ### # # # # # # ##### ##### # ### #",
	 "#   #   #     # # # # #         #   #   #     #   # #   #   #   # #     #   #   #",
	 "# # # ### ### # # # # # ####### ### ### # # ### ##### ######### # # ### ##### ###",
	 "# #   #   # #   #   # # #     #   # #   # #   #     # #   #   #   # # # #   #   #",
	 "# ##### ### # ####### # ##### # # # # ### ######### # ### # # ##### # # # # # ###",
	 "#     #     #   #     #     # # #   #     #   #   # #   # # #       # # # # #   #",
	 "# ##### # ##### # ######### # ####### ##### # ### # # # # # ######### # ### # # #",
	 "#   #   # #   #     #     #   #     #     # #   # # # #   #   #       #     # # #",
	 "### # ### # ####### # ### ##### ### ##### # ### # # # ######### # ########### # #",
	 "#   # # #       # #   #       #   #     # # # #     # #         #   #     #   # #",
	 "# ### # ####### # ##### ######### ##### ### # # ##### # ######### # # ##### # # #",
	 "# #   #   #     #       #   #     #   #     # # #   # # #     #   # #   #   # # #",
	 "# # ##### # ############# ### ### # # ####### # # # # # ### # # ### ### # ##### #",
	 "#   #   # #             #   #   # # # #   #   #   # # # #   # #   # #   # #   # #",
	 "##### # # ######### ### ### ### ### # # # # ####### # # # ##### # # # ### # # # #",
	 "#   # #           #   #   #   #     #   # #   #       # # #     # # #   # # #   #",
	 "# ### ########### ### # ### ### ######### # # ######### # # ##### ### # # # #####",
	 "# #   #     #   # #   #   #   # #     #   # #   #     # #   # #   #   # # # #   #",
	 "# # ### ### # # # # ##### ### # # ### # ####### # # # # ##### # ### # # # # # ###",
	 "# # #     #   #   # #   #     # # #   #         # # # #       #   # # # # #     #",
	 "# # # ### ########### # # ##### # ######### ##### # ### ######### # ### # ##### #",
	 "#   #   # #       #   #   #     #         #       #     #   #     #   # # #     #",
	 "####### # # ##### # ##################### ########### ### # # ####### # # # #####",
	 "#     # # # #   #   #     #     #   #   # #     #   # #   # # #       # # #     #",
	 "# ### # ### # ####### # # # ### ### # # # # # # # # # # ##### # # ####### #######",
	 "# # #       # #       # #   #   #   # # #   # # # # # # #     # #   # #   #     #",
	 "# # # ####### # ####### ##### ### ### # ##### # # # ### # ### # # # # # ### ### #",
	 "#   # #     # #       # #   #   #     #   # # #   #     #   #   # #   #     # # #",
	 "##### # ### # ####### ### # # ########### # # # ### ####### ####### ######### # #",
	 "#   #     #         #   # # #       #   # # # # # #   #     #     #   #   #   # #",
	 "# ### # ########### ### # # ####### # # # # # # # # # # ##### ### ### # # # ### #",
	 "# #   # #   #   #     #   #       #   #     # # # # #   #     #   # # # #     # #",
	 "# # ##### ### # ########### ############# ### # # ####### ##### ### # ### # # # #",
	 "# #     #   # #     #   #   #     #     #   # # #       # #     #   #     # #   #",
	 "# ### # ### # ##### # # # ### ### # ### ##### # # ##### # # ##### ######### #####",
	 "#   # #   # # #     # #   #   #   #   #       # #     #   #   #   #   #     #   #",
	 "### ##### # # ####### # ### ### ##### ########### ### ####### # ### # ####### # #",
	 "#     #   # #       # #   # #   #   #           # #   #       #   # #       # # #",
	 "### # # ### ####### # ### # # ### # ########### ### ####### ### # # ####### # # #",
	 "#   # # #   #   #   #   #   #   # #   #             #     #   # # #   #   # # # #",
	 "# ##### # # # # # ##### # ##### ### # ############### ### ##### # ### # # # ### #",
	 "#         # # # # #     # #   # #   #         #     #   #       # #   # # #   # #",
	 "# ##### ### # # # # ####### # # # ##### ##### # ##### # ######### # ### # ### # #",
	 "# #   #   #   # # #     #   # # # #   # # #   #   #   # # #   #   # #   #   #   #",
	 "# # # ######### # ##### # ### # # # # # # # # ### # # # # # ### # ### ##### # ###",
	 "# # #   #     # #     # #   # #     # #   # #     # # # # #   # #   #     #     #",
	 "### # # # ### # ##### # # # ######### ##### ####### # # # ### # ### ########### #",
	 "#   # #   #   #   #   # # #         # #   #   # #   # #   # #   #       #   #   #",
	 "# ##### ####### # # ### # ######### # # # ### # # ####### # # ### ####### # # ###",
	 "# #   # #     # # #   # #   #   # # # # #   #   # #     # # #   #         # #   #",
	 "# # # # # ### # ### # # ### # # # # # # # ### ### # ##### # # # ########### ### #",
	 "#   # #   # #   #   # # # # # #   #   # # #   #   #     #   # #   #   #   #     #",
	 "##### ##### # ### ### # # # # # ####### # # ### ####### ##### ### # # # #########",
	 "#           #       #     #   #         # #           #         #   #           #",
	 "############################################################################### #",
	 0};

    solve(large);

    return 0; 
}

void read(const char **data)
{
    unsigned int i = 0;
    const char* s;

    while( (s = data[i++]) != 0)
    {
        std::string str(s);
        Matrix::matrix_row row(str.size());

        for(std::size_t j = 0; j < str.size(); ++j)
        {
            row[j] = str[j] == '#'? 1 : 0;
        }
        maze.add_row(row);
    }
}

void findStartGoal(std::size_t &startX, std::size_t &startY,
                   std::size_t &endX  , std::size_t &endY)
{
    bool foundStart(false), foundEnd(false);
    // ** Go through the borders of the maze
    for(unsigned int i = 0; i < maze.rows(); ++i)
    {
        for (unsigned int j = 0; j < maze.cols(); ++j)
        {
            if( inBorder(i,j,maze.rows(), maze.cols()) && maze[i][j] == 0)
            {
                if(!foundStart)     {startX = i; startY = j; foundStart = true;}
                else                {endX = i; endY = j;     foundEnd = true;}
            }
        }
    }

    // ** Check that we actually found the solution
    if(!foundStart || !foundEnd)
        std::cout << "Could not find start and end!" << std::endl;
}

bool inBorder(std::size_t x, std::size_t y, std::size_t x_max, std::size_t y_max)
{
    return (x == 0 || x == x_max -1 || y == 0 || y == y_max -1);
}

bool solve_maze(std::size_t x, std::size_t y)
{
    if (x == endX && y == endY)
    {
        path[x][y] = 1;
        return true;
    }

    if (maze[x][y] == 1 || visited[x][y]) return false;         // If you are on a wall or already were here

    // ** New waypoint
    visited[x][y] = 1;
    if (x != 0)
        if (solve_maze(x-1, y))
        {
            path[x][y] = 1;
            return true;
        }
    if (x < maze.rows())
        if (solve_maze(x+1, y))
        {
            path[x][y] = 1;
            return true;
        }
    if (y != 0)
        if (solve_maze(x, y-1))
        {
            path[x][y] = 1;
            return true;
        }
    if (y < maze.cols())
        if (solve_maze(x, y+1))
        {
            path[x][y] = 1;
            return true;
        }
    return false;
}

void solve(const char** file)
{
    // ** Read the map
    read(file);
    visited = Matrix(maze.rows(), maze.cols());
    path = Matrix(maze.rows(), maze.cols());

    // ** Find start and goal positions
    findStartGoal(startX, startY, endX, endY);

    // ** Solve maze
    solve_maze(startX, startY);

    // ** Output solution
    std::cout << path << std::endl;
}
